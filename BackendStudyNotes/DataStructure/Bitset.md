Java平台的BitSet用于存放一个位序列，如果要高效的存放一个位序列，就可以使用位集(BitSet)。由于位集将位包装在字节里，所以使用位集比使用Boolean对象的List更加高效和更加节省存储空间。

BitSet是位操作的对象，值只有0或1即false和true，内部维护了一个long数组，初始只有一个long，所以BitSet最小的size是64，当随着存储的元素越来越多，BitSet内部会动态扩充，一次扩充64位，最终内部是由N个long来存储。
 
默认情况下，BitSet的所有位都是false即0。

          在没有外部同步的情况下，多个线程操作一个BitSet是不安全的。
          
     
应用场景：
- 统计一组大数据中没有出现过的数；

        将这组数据映射到BitSet，然后遍历BitSet，对应位为0的数表示没有出现过的数据。

- 对大数据进行排序；

        将数据映射到BitSet，遍历BitSet得到的就是有序数据。
- 在内存对大数据进行压缩存储等等。

        一个GB的内存空间可以存储85亿多个数，可以有效实现数据的压缩存储，节省内存空间开销。
        
          
***     
| Symbol | Prefix |   SI Meaning   | Binary meaning | Size difference |
|:------:|:------:|:--------------:|:--------------:|:---------------:|
| k      | kilo   | 10^3 = 1000^1  | 2^10 = 1024^1  | 2.40%           |
| M      | mega   | 10^6 = 1000^2  | 2^20 = 1024^2  | 4.86%           |
| G      | giga   | 10^9 = 1000^3  | 2^30 = 1024^3  | 7.37%           |
| T      | tera   | 10^12 = 1000^4 | 2^40 = 1024^4  | 9.95%           |
| P      | peta   | 10^15 = 1000^5 | 2^50 = 1024^5  | 12.59%          |
| E      | exa    | 10^18 = 1000^6 | 2^60 = 1024^6  | 15.29%          |
| Z      | zetta  | 10^21 = 1000^7 | 2^70 = 1024^7  | 18.06%          |
| Y      | yotta  | 10^24 = 1000^8 | 2^80 = 1024^8  | 20.89%          |

- 程序里的内存默认是指上面表的Binary meaning，而硬盘内存大小一般是指SI Meaning。
- 1 bit：基本单元，只能表示0或1
- 1 byte：也是 1B，字节，8个bit，表示[0,256)的一个数字。
- 一般来说算法只关注复杂度，所以会忽视 size difference，绝大多数时候为了方便都是默认转换使用 10^n 这种形式，更加直观。  

        char ：1个字节
        short int : 2个字节
        int：  4个字节
        unsigned int : 4个字节
        float:  4个字节
        double:   8个字节
        long:   4个字节
        long long:  8个字节
        unsigned long:  4个字节
        需要特殊注意的是：
        char*（指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器是8个字节）